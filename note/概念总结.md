## 页表、地址转换、PTE格式

![SV39](D:\GitHubLocalRepository\xv6\note\picture\SV39.png)



## Caller Saved & Callee Saved

1. caller saved - 调用者保存
2. callee saved - 被调用者保存

最显著的区别：**callee saved的寄存器不会因为函数a调用函数b后被改变，caller saved的寄存器则会**

理解：**callee saved寄存器不能被被调用者修改**，意味着被调用者负责把这些寄存器维持不变；caller saved会被修改，意味着调用者自行保存，返回的时候调用者自己进行恢复

以ra寄存器（return address）为例：调用者必然需要被调用者改写该寄存器，被调用的函数才能返回调用者，而调用者也有自己的ra的值以返回更上一层的调用者。所以这就是一个caller saved的寄存器。

可以说callee saved的寄存器是相对【不能动的】。例如栈指针寄存器sp，所有函数都共用一个栈，不能因为调用某个函数而改变，所以是callee saved



## 跳板 Trampoline

uservec：用户发生陷入时跳转到地址。也就是内核处理陷入的第一个函数。

uservec的特殊性：硬件在陷入期间不会切换页表，所以uservec需要完成**切换地址空间**（从用户到内核）的操作，所以用户页表需要有uservec的映射。而为了保证指令执行的连续性，uservec还需要在内核与用户页表中映射相同的（虚拟）地址。这样在切换页表之后内核能继续正常执行。所以uservec这段代码被放在了trampoline page中。trampoline在用户与内核空间都映射到同样的位置。



## 地址空间

### 内核地址空间

![img](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p3.png)

### 进程地址空间

![img](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p6.png)



*各段的含义？所存放的内容？*

## RISCV中的栈

![img](https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM3Hk7Gv6ibvM2lxjCc%2F-MM4D2J3t3ajqkngxRPC%2Fimage.png?alt=media&token=1f78ffd1-9322-4666-85f2-8aa831ced49e)

1. 一个程序使用一个栈stack，一个函数使用一个栈帧frame
2. 栈一开始为空，所以最开始sp在**“栈底”，也就是在栈的最高地址**。随着函数的调用，sp不断往低地址移动，sp移动一次，相当于开辟一个frame
3. 每一个fp都在frame的最高地址处。(fp - 8)、(fp - 16)分别固定放着当前函数的ra、以及上一个frame的地址，等等。sp始终在“栈顶”，也就是整个栈的最低地址处。
4. xv6中的内核栈：每个进程都有一个栈。在初始化时，每个kernel_sp都在各栈的栈顶（最低地址处）。使用时需要把sp置于kernel_sp+PGSIZE的位置（即各栈的最高地址，也就是栈底），随着使用过程中的函数调用，sp逐渐减小。
5. riscv的函数调用时，每次调用sp都会自减，相当于开辟栈帧。这与xv6内核栈的使用是一致的



## RISCV寄存器

### 通用寄存器

![RISCV_Register](D:\GitHubLocalRepository\xv6\note\picture\RISCV_Register.png)

### scause

![scause](D:\GitHubLocalRepository\xv6\note\picture\scause.png)



## Lazy Allocation

### lazy sbrk

当用户希望扩展堆时，不进行实际的内存分配，而只是修改进程的sz标志。等出发了page fault再进行分配

### zero-fill-on-demand

把初始化为0的虚拟地址段全部映射到一个page上，只读。

当对某个段中的虚拟地址写时，触发pagefault，为该地址所属页分配一个物理页并赋写权限。

### copy-on-write fork

fork的时候不为子进程分配页，而是全部映射到父进程的物理页面，父子进程对共享页面权限都为只读。当出现写而产生的pagefault时，为父子进程各复制一个该page，权限为写

*疑问：应该不是所有的页都不分配吧？至少像栈这样的数据是一定会修改的，如果也映射到父进程，那必然马上会发生page fault?*
*应该是把除了栈以外的都采用COW，栈应该还是要在fork的时候马上分配的。*

### memory mapped files

mmap(va, len, protection, flags, fd, offset) 系统调用会把文件描述符中对应长度的内容写到va中。在后续操作了va中某些页，使其变成dirty之后，把dirty的页写回到文件中。

这里也可以用lazy的方法。在文件map到内存的时候只map到虚拟内存中，当真正使用到mapped files的内容时，再触发page fault从文件中读进来



## 设备驱动

### Top

在进程的内核线程中运行。进程通过系统调用，例如read、write，对硬件发送执行请求。然后代码等待操作完成。

### Bottom

设备操作完成，引发中断。中断处理程序作为驱动程序的下半部分。bottom部分只完成一些简单的工作，例如往缓冲区写。并不运行在任何context中。因为触发中断时的正在运行的进程并不一定是执行了Top部分的进程



## XV6的进程与线程

xv6中，进程process一般指的是用户进程，是整个proc对象。一个进程有自己的地址空间，被分配了实际的内存。当然内核也有进程，整个内核的运行就可以视为一个进程，但是从控制流的角度暂时忽略“内核进程”的说法。

线程指的是一段控制流，一段占用一个cpu的、串行运行的代码单元。线程的概念更多是逻辑上的概念，不占用（或占用的是进程的）物理资源。可以理解成进程的“执行片段”。

xv6中，把用户进程分成了“用户线程”和“内核线程”。

- 用户进程在用户空间的控制流归为用户线程
- 当用户线程因为系统调用或其他中断陷入内核时，直到调用swtch之前，此时都视为用户进程的内核线程

当用户的内核线程调用了swtch之后，此时进入了“内核调度线程”。这是一个和用户进程无关的线程。每一个CPU都有一个内核调度线程。

因为线程是一段控制流，一段代码的执行，无论线程如何命名，每一段线程都必须有一个自己的栈。所以可以用栈来区分不同的线程。用户的用户线程使用的是在用户地址空间下的用户栈；用户的内核线程使用的是内核用户栈。内核的调度器线程在xv6启动最开始的时候定义，是每个cpu上都有一个的栈，此栈专门为内核调度线程执行调度代码时使用。

区分这三类线程对于xv6的线程切换至关重要。

## xv6进程的状态

- RUNNING：正在运行的线程，此时不可被调度和切换
- RUNNABLE：就绪的线程。只要调度器能拿到进程锁就可以随时运行。被唤醒的、被切出的、刚创建准备好的进程都处于这个状态
- SLEEP：主动放弃cpu等待唤醒的进程。通过对sleep()的调用进入睡眠状态，在等待条件【&chan（保存在进程结构体中）】被wake调用时结束睡眠状态。
- ZOMBIE：进程退出但未完全退出时的状态。因为一个正在运行的进程、代码没办法自己一边运行一边完全释放自己。一个进程的完全释放需要依赖他的父进程进行，需要有一个正在wait当前进程结束的父进程帮助自己释放。
  在exit的过程中，进程唤醒自己的父进程，关闭自己的文件，把自己变为僵尸态，僵尸态中的进程之后不可能再被调度，离死去只剩一步之遥。最后调用sched切出当前进程。之后被唤醒的父进程真正把僵尸态的进程杀死，释放所有内存，变为UNUSED态
- UNUSED：空闲进程，可随时被分配/重用。

## 条件锁

## XV6 - sleep(&chan, &lock) / UNIX原语 - pthread_cond_wait(&cond, &mutex) 中的锁

> 首先我们必须要释放uart_tx_lock锁，因为中断需要获取这个锁，但是我们又不能在释放锁和进程将自己标记为SLEEPING之间留有窗口。这样中断处理程序中的wakeup才能看到SLEEPING状态的进程，并将其唤醒，进而我们才可以避免lost wakeup的问题。所以，我们应该消除这里的窗口。
>
> sleep函数设计的稍微复杂点。这里的解决方法是，即使sleep函数不需要知道你在等待什么事件，它还是需要你知道你在等待什么数据，并且传入一个用来保护你在等待数据的锁。
>
> sleep承诺可以原子性的将进程设置成SLEEPING状态，同时释放锁。这样wakeup就不可能看到这样的场景：锁被释放了但是进程还没有进入到SLEEPING状态。sleep这里将释放锁和设置进程为SLEEPING状态这两个行为合并为一个原子操作。
