## 页表、地址转换、PTE格式

![SV39](D:\GitHubLocalRepository\xv6\note\picture\SV39.png)



## Caller Saved & Callee Saved

1. caller saved - 调用者保存
2. callee saved - 被调用者保存

最显著的区别：**callee saved的寄存器不会因为函数a调用函数b后被改变，caller saved的寄存器则会**

理解：**callee saved寄存器不能被被调用者修改**，意味着被调用者负责把这些寄存器维持不变；caller saved会被修改，意味着调用者自行保存，返回的时候调用者自己进行恢复

以ra寄存器（return address）为例：调用者必然需要被调用者改写该寄存器，被调用的函数才能返回调用者，而调用者也有自己的ra的值以返回更上一层的调用者。所以这就是一个caller saved的寄存器。

可以说callee saved的寄存器是相对【不能动的】。例如栈指针寄存器sp，所有函数都共用一个栈，不能因为调用某个函数而改变，所以是callee saved



## 跳板 Trampoline

uservec：用户发生陷入时跳转到地址。也就是内核处理陷入的第一个函数。

uservec的特殊性：硬件在陷入期间不会切换页表，所以uservec需要完成**切换地址空间**（从用户到内核）的操作，所以用户页表需要有uservec的映射。而为了保证指令执行的连续性，uservec还需要在内核与用户页表中映射相同的（虚拟）地址。这样在切换页表之后内核能继续正常执行。所以uservec这段代码被放在了trampoline page中。trampoline在用户与内核空间都映射到同样的位置。



## 地址空间

### 内核地址空间

![img](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p3.png)

### 进程地址空间

![img](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p6.png)



*各段的含义？所存放的内容？*

## RISCV中的栈

![img](https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM3Hk7Gv6ibvM2lxjCc%2F-MM4D2J3t3ajqkngxRPC%2Fimage.png?alt=media&token=1f78ffd1-9322-4666-85f2-8aa831ced49e)

1. 一个程序使用一个栈stack，一个函数使用一个栈帧frame
2. 栈一开始为空，所以最开始sp在**“栈底”，也就是在栈的最高地址**。随着函数的调用，sp不断往低地址移动，sp移动一次，相当于开辟一个frame
3. 每一个fp都在frame的最高地址处。(fp - 8)、(fp - 16)分别固定放着当前函数的ra、以及上一个frame的地址，等等。sp始终在“栈顶”，也就是整个栈的最低地址处。
4. xv6中的内核栈：每个进程都有一个栈。在初始化时，每个kernel_sp都在各栈的栈顶（最低地址处）。使用时需要把sp置于kernel_sp+PGSIZE的位置（即各栈的最高地址，也就是栈底），随着使用过程中的函数调用，sp逐渐减小。
5. riscv的函数调用时，每次调用sp都会自减，相当于开辟栈帧。这与xv6内核栈的使用是一致的



## RISCV寄存器

### 通用寄存器

![RISCV_Register](D:\GitHubLocalRepository\xv6\note\picture\RISCV_Register.png)

### scause

![scause](D:\GitHubLocalRepository\xv6\note\picture\scause.png)



## Lazy Allocation

### sbrk

当用户希望扩展堆时，不进行实际的内存分配，而只是修改进程的sz标志。等出发了page fault再进行分配

### zero-fill-on-demand

把初始化为0的虚拟地址段全部映射到一个page上，只读。

当对某个段中的虚拟地址写时，触发pagefault，为该地址所属页分配一个物理页并赋写权限。

### copy-on-write fork

fork的时候不为子进程分配页，而是全部映射到父进程的物理页面，父子进程对共享页面权限都为只读。当出现写而产生的pagefault时，为父子进程各复制一个该page，权限为写

*疑问：应该不是所有的页都不分配吧？至少像栈这样的数据是一定会修改的，如果也映射到父进程，那必然马上会发生page fault?*
*应该是把除了栈以外的都采用COW，栈应该还是要在fork的时候马上分配的。*

### memory mapped files

mmap(va, len, protection, flags, fd, offset) 系统调用会把文件描述符中对应长度的内容写到va中。在后续操作了va中某些页，使其变成dirty之后，把dirty的页写回到文件中。

这里也可以用lazy的方法。在文件map到内存的时候只map到虚拟内存中，当真正使用到mapped files的内容时，再触发page fault从文件中读进来
