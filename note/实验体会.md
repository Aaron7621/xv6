## 实验二

实验的意义：在进程进入内核态的时候，使用进程自己的内核页表，而不是所有进程共享一个内核页表。

1. kvmmap panic的原因：可能是因为内存泄漏。在free进程内存资源的时候，一定要仔细检查是不是所有东西都free掉了。
2. 内核栈的分配时机：这个是灵活的。可以在进程模块初始化的时候分配（kalloc）好所有内核栈，也可以在一个进程需要被拉起的时候再分配。后者则需要在回收进程，freeproc()的时候把内核栈回收掉。
3. 内核栈的映射：可以只映射某一个进程的内核栈到进程内核页表中；也可以把所有内核栈都映射到内核全局页表中，也可以两者都映射。关键的是内核栈只能有一个，映射能有多个，同时也要搞清楚什么时候换地址空间，换了之后当前页表是否有内核栈的映射以供使用。
4. free内核页表的方式：如果内核栈的映射在全局内核页表中，那就没必要在拉起和结束每个进程的时候分配和回收内核栈，只需要管理好进程内核页表中的映射即可。如果是每次拉起进程才分配内核栈，并且进程内核栈的映射只存在于进程内核页表中，就需要在freeroc的时候释放内核栈并删除映射
5. kvmpa是根据全局内核页表翻译一个va。别人的代码中有对它进行修改，改为多接受一个pagetable_t的方式，这样会导致其他模块调用这个函数的时候都需要多传入一个pagetable_t参数。之所以这么设计是因为该答案的实现是在拉起进程的时候分配内核栈，并且内核栈映射只存在于进程内核页表中。所以回收时需要接受当前内核进程页表为参数，找到内核栈的物理地址并回收。
     而如果把内核栈的映射同时放在全局内核页表和进程内核页表，就没有修改kvmpa的必要。甚至没有回收内核栈的必要。