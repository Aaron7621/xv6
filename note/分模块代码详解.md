# 启动

1. entry.S：整个内核的入口，通过kernel.ls将其连接到0x80000000的位置，也就是qemu执行首条指令的地址。随后程序为C内核设置一个最开始的栈
2. 跳转到start.c/start()，主要完成从机器模式到监管者模式的切换，初始化时钟中断
3. 跳转到main.c/main()。main()执行几乎所有模块的初始化和启动。

   多核CPU的初始化是这样的：

   1. CPU0完成大部分模块的初始化，包括第一个用户程序userinit的拉起。在初始化完成，此时内核在单CPU下也能运行，把start标志置为1.
   2. 其余所有CPU在CPU0初始化的过程中一直自旋等待，直到start为1. 则各cpu初始化一些per cpu的程序（以hart结尾的初始化程序），这些程序初始化的是每个CPU上都有的硬件。（显然在CPU0初始化的时候这些程序也被CPU0调用的）
   3. 然后所有CPU调用scheduler，进入各CPU的内核调度线程
4. 各模块初始化完毕后，main()调用userinit()初始化第一个程序。userinit()实际执行了数组initcode中的二进制指令，对应user/initcode.S中的代码，其执行了一个exec系统调用，exec了init用户程序。init通过fork+exec启动shell。
5. shell：父进程一直等待，如果子进程退出，父进程重启shell。

*疑问：在trap初始化时是吧kernelvec写进stvec，作为陷入的入口。而把uservec写入stvec的操作发生在usertrapret中。在内核启动、第一次返回用户空间的时候应该会调用usertrapret才对，不然怎么调用sret返回、以及怎么写好uservec以供后面用户程序系统调用呢？*

*但是没有找到内核第一次返回用户空间时具体发生在哪。在main()执行完userinit()，初始化了第一个进程后，main()最后调用了scheduler，scheduler中调了swtch.S进行任务切换。但是swtch.S中并没有sret*



# 内存

## riscv.h

包含页表操作时用到的几个宏

PGSIZE - 页表字节数：4096

PGSHIFT - PTE偏移量的位数：12。即每个页表的”页内地址“，因为一页表4096字节，所以用12位访问。

PXSHIFT(level)  - 给出多级页表当前需要的层数，返回获得当前级页表的PTE时，当前地址需要右移的位数。

PX(level, va) - 根据虚拟地址和当前层数，获得在PTE在当前页表的地址（偏移量），一共9位（因为一页有512 =  2^9）个PTE

## kernel/vm.c

主要是和页表操作相关的代码。

1. walk()：获取va对应的地址所在的物理页表地址，也就是第三级页表的PTE。

   i. alloc参数：一级页表（根页表）是一定存在的，存在SATP中。而如果alloc == 1，在walk的过程中二、三级页表不存在则创建二、三级页表。如果二三级页表不存在，且alloc == 0或页表创建时内存分配失败，返回0。意味着无法访问va对应pa所在的物理页号。

   最后返回三级页表中的PTE，此PTE保存了va所对应pa所在的物理页。此时的PTE只是“找到对应的”，但是并未检查合法性和其中的值，可能是空的（新分配）。

2. mappages：接收一段不一定对齐的虚拟地址与一个物理地址，及要映射的范围，把范围内所有虚拟页所对应的物理页都映射页表中，返回-1如果创建多级页表时资源分配失败。这个函数只涉及页表映射，不涉及实际资源的分配，即要**先分配了资源，获得了pa，才能调用这个函数将映射写到页表**

3. uvmalloc

   1. 参数：页表、旧的size，新的size
   2. 如果新size大于旧size而且跨页了，那么分配所有包含的新的页。如果某一新页分配失败了，调用uvmdealloc将之前分配的新的页全部回收并返回；如果某一新页分配成功但是也表映射失败了，把那一页回收，同时把之前分配成功的新的页页全部回收并返回。

4. uvmdealloc：传入oldsz和newsz，调用uvmunmap回收页。映射的页表项以及具体分配的页都会被回收。

5. uvmunmap：解除一段连续的虚拟地址范围在页表中的叶子映射并且释放掉相应的物理资源。根据va是可以获得pa的，所以可以在这个函数中完成**删映射+释放物理页**。也可以通过参数指定不释放掉相应的物理页，只删除虚拟地址范围对应的PTE。

6. freewalk：在三级页表的PTE已经全部删除之后才能使用。PTE指向真正物理内存页（而不是下一级页表）的PTE必须已经清除。该函数会将一、二、三级页表的映射以及页表本身全部清除、释放。

7. uvmfree：先调用uvmunmap删除掉一段虚拟地址范围的【叶子PTE】与【对应PTE的物理页】，再通过freewalk删掉页表叶子节点以外的所有PTE。这个函数可以把用户地址空间全部回收。



# 陷入

## 相关寄存器

stvec：内核的中断处理函数的地址。Trap之后把它写入pc
sepc：trap完之后的恢复地址，sret之后sepc写入pc
scause：trap原因描述
sscratch：在中断时可作为缓冲使用
sstatus：SIE位标志设备中断是否启用。如果内核清空SIE，推迟设备中断。SPP位指示中断发生时（前）的特权级，并控制sret返回的模式。

## kernel/trap.c

1. usertrap：
     a. 写kernelvec到stvec，让来自内核的陷入可以跳转到该处

     b. 把sepc寄存器的值存到当前进程的trapframe中。这个值来源于在ecall的时硬件自动保存当时的pc，以让ecall结束后返回用户代码。此处第二次将这值保存到内存是因为usertrap中可能会发生的进程切换，覆盖原有sepc
     c. 根据scause处理陷入。如果scause==8，即系统调用。把trapfrmae中保存的sepc加4,即用户程序ecall后的下条指令。然后调用syscall系统调用分发函数。如果是设备中断，则调devintr()处理。处理完后如果是时钟中断，则让出cpu。

     d. 系统调用返回，则调usertrapret

2. usertrapret：
     a. 把stvec设置回uservec的地址。这里大概可以推断出，来自内核的陷入应该只会发生在usertrapvec到usertrapret之间？或者说一定发生在是在用户陷入的基础之上？
     b. 设置好trapframe中的内核页表、内核栈、usertrap地址、hartid等。这些字段在uservec保存好用户寄存器后，跳转到内核陷入处理函数时需要使用.

     *疑问：trapframe中的这些字段按理来说不会被修改，这样设置是只有第一次返回用户空间的时候有用吗？*
     c. 设置好sepc寄存器为之前保存的（ecall下一行指令的位置）；
     b. 获取（还没设置）satp为用户页表。trapframe中没有保存用户页表的地址，所以需要在这里通过保存在进程结构体中的p->pagetable，作为参数传给userret。
     d. 获取userret地址，传入trapframe与用户页表，调用跳转至userret

## kernel/trampoline.S

此处保存了用户陷入时执行的第一个函数uservec以及内核返回用户空间执行的最后一个函数userret

  1. uservec

  a. 在trap.c中把uservec装进stvec，用户陷入时首先跳转到这里。

  b. 从sscratch获得当前进程的trapframe。sscratch与a0交换使a0可以暂时使用。通过a0地址保存32个当前的寄存器的值（包括存在sscratch中的a0）。然后从trapframe中加载内核栈到sp、加载usertrap地址到t0、加载内核页表到t1并写入satp，然后jr到t0。
  **注意：**uservec的注释中，在切内核页表后写道，“a0此时不再valid”，指a0寄存器的值本来存的是（用户地址空间下的）trapframe，但是内核页表中没有每一个进程的trapframe的映射，所以a0此时的值是没有意义的。

  2. userret

a.  切用户页表（为了使用trapframe的内容，需要用户页表才有映射）
b.  根据入参，此时a0是trapframe地址，a1是用户页表（文档说反了）。所以恢复32个通用寄存器的时候需要用到a0的地址，但同时又要恢复a0本身。因此过程是：先把tramframe中保存了的a0值（即ecall前的a0）写入sscratch，然后用当前a0（即作为入参、正指向trapframe的a0寄存器）从trapframe恢复除了a0的寄存器，最后当前a0与sscratch交换。所以sscratch此时同时保存了进程trapframe的地址，下次陷入时可以再使用。
c. 调用sret返回sepc的地址，恢复陷入前的特权级。



# 系统调用

## user/usys.pl  &  user/usys.S

1. usys.pl是一个生成usys.S的脚本
2. usys.S中定义了用户层面的系统调用接口（函数），所有系统调用都只做两件事
   1. 把当前对应的系统调用号写入a7寄存器中
   2. 调用ecall

## kernel/syscall.h & kernel/syscall.c

1. syscall.h: 定义了所有系统调用的调用号，后续内核处理不同系统调用时根据这个号进行分发
2. syscall.c：ecall之后，根据中断处理函数usertrap，属于系统调用的中断来到syscall.c/syscall()中。syscall()从p->trapframe -> a7获得系统调用号，因为在中断时用户传入a7的系统调用号最终会在中断处理后存到进程的p -> trapframe中。
3. 同理，syscall.c中的获取用户实参的函数argraw()，也是根据p -> trapframe中保存的a0、a1获得用户系统调用的传入参数。

*疑问：在uservec中提到切换内核页表后，由于没有进程trapframe的映射，存放trapframe地址的a0不再有用。那么为什么内核可以通过p -> trapframe访问trapframe呢？*
*因为a0存的是trapframe在进程空间中的虚拟地址。而p -> trapframe存的是trapframe的物理地址。内核使用恒等映射，因此可以直接通过物理地址访问trapframe*



# 中断

## 控制台输入

1. main函数最开始调用console.c/consoleinit()。
   1. consoleinit()调uartinit()，配置了uart硬件：UART之后对接收的每个字节输入生成一个接收中断，对发送完的每个字节输出一个发送完成中断。具体操作是为部分uart寄存器设了值
   2. 把consoleread和consolewrite函数指针写到了一个全局数组中，可以被read和write系统调用获取
2. 对控制台输入文件描述符的read系统调用，控制流最终走向console.c/consoleread()。consoleread()主要工作是获得cons（console.c中的一个全局的结构体对象，主要是维护了一个缓冲区，用于与中断设备交互）的锁后，对锁进行sleep，等待后续被中断唤醒。这一步就是中断处理的上半部分。
3. 当用户输入一个字符，uart发送一个中断，trap通过sscause判断当前陷入是来自中断，调用trap模块中的中断处理devintr()。devintr()通过PLIC获得当前中断设备，如果设备是uart，调用uartintr()。
4. uartintr通过uartgetc()从uart硬件读取等待输入（到程序的）字符，并交给consoleintr处理。uartgetc()具体通过LSR寄存器判断字符是否ready后，读RHR寄存器中的字符。
5. consoleintr将字符在cons.buf缓冲区累积，对部分字符对特殊处理（如backspace）。当读到换行符后，则唤醒consoleread。consoleread再将cons.buf缓冲区中的字符copyout到用户空间所在地址。3-5步就是中断处理的下半部分。



## 控制台输出

1. 对写控制台的write，最终调用到console.c/consolewirte()。该函数把write的字符串从用户空间copyin进来后，对各字符调uartputc()
2. uartputc负责将传入字符写到输出缓冲区，然后调用uartstart()就返回。uartputc()不会等待输出的完成，只会在缓冲区满的时候等待。1、2是中断的上半部分
3. uartstart()介于输出中断处理上下两部分之间，它既被上半部分的uartputc调用，也在中断发生时被调用。
   1. uartputc()每写一个字符到缓冲区都会调一次uartstart()。而uartstart的返回（退出）是不确定的。缓冲区写完了uartstart会退出（这是必然的），而THR（即接收输出字符的寄存器）还没有准备好时也会直接退出。如果THR总能在要写下一个字符的时候ready，uartputc()就把缓冲区写完为止。
   2. 当uart发送完一个字节，也会产生发送完成中断。uartintr调用uartstart，完成与上一步一样的工作。这属于中断处理的下半部分。
      之所以同样的操作在中断的上下部分都进行，是因为如果uartputc要写下一个字符的时候THR没准备好，最终缓冲区的字符就不能完整输出。所以在中断发生后（因为这是上一个字符传输完成后产生的中断，此时THR一定ready了）要继续调一次uartstart()。有了中断后半部分的调用，哪怕uartstart()每次都只能成功写一个字符到THR，也能保证整个缓冲区写完。而uartputc()对uartstart()的调用则是“启动”了写的过程。不然后面也不会产生传输完成的中断。



输入缓冲区的存在可以在即使没有进程等待输入时，控制台驱动也可以处理输入，而后续进程的读取也可以获得这些输入。输出缓冲区的存在可以让进程无需等待就可以发送输出。
缓冲区的存在使得进程与设备IO完成了解耦，提高了并发。驱动处理的“两步走”就是围绕缓冲区进行的。



# 线程切换

## 切出

### trap.c

1. 用户线程因为时钟中断（或其主动放弃cpu），触发trap，保存好用户线程的trapframe，进入内核。此时的控制流为用户程序的内核线程（因为使用的是用户内核栈）。
2. 如果是时钟中断，调用proc.c/yield()。

### proc.c

1. yield()：让出cpu的函数。首先获取当前进程的进程锁（为了保证当前正在让出cpu的操作原子性，不会再这个过程中被其他cpu调度），修改进程的状态从RUNNING到RUNNABLE。然后调用sched()
2. sched()：在线程“切出”这一步中的swtch函数调用方。在对进程做了一系列检查后，调用swtch()函数。因此此时进入swtch函数后，**RA寄存器的地址就是sched**（因为sched是swtch的调用方）。这对后面理解切入的过程很重要。
3. swtch()：swtch.S/swtch()主要将线程（**当前还是用户的内核线程**）的ra（即sched的地址）和sp（即用户的内核栈地址）、以及callee saved寄存器保存在进程的context中（p -> context），用于下次切入时使用。然后把当前cpu的context（保存了内核调度线程的sp、ra和callee saved寄存器）load到相应寄存器中
4. 随后根据cpu context load进来的ra，和sp，完成换栈（内核调度线程栈，每cpu一个）。swtch函数结束后根据ra返回到proc.c/scheduler()函数。返回的不是调用当前swtch的sched，而是本cpu上一次调用swtch的地方（也就是scheduler()）。这是线程切换最核心的地方

## 切入

### proc.c

1. 切入一个用户进程，发生在proc.c/scheduler()中。scheduler()运行在内核调度器线程中。当一个进程经历用户线程-内核线程-内核调度器线程（上文所述的过程）切出后，cpu的返回到scheduler()里的swtch()中。cpu首先释放了进程的锁，这个锁在yield获取，在scheduler释放，用来确保进程进行切出时其他cpu无法调度该进程。现在释放之后该进程就可以被其他cpu进行调度了。
2. 随后scheduler遍历所有进程，找到RUNNABLE状态的进程，并获得进程锁。将其标为RUNNING，然后调swtch**切入该进程的内核线程**
3. swtch把当前cpu内核调度线程保存在cpu->context中（所以本cpu之后在运行切入时就可以从自己的cpu对象中找到找到内核调度线程的上下文了），把要调度的进程的内核线程上下文load进响应的寄存器。
   然后用ret指令返回。因为此时的RA是p->context中的ra，也就是该进程的内核线程上次切出、在sched调用swtch时保存的ra，所以**现在ret指令后将返回到上次该进程的内核线程调用swtch切出的地方**，也就是sched()，而不是scheduler
4. 此时cpu已经切换到了用户进程的内核线程。sp也指向进程的内核栈。swtch返回到sched()后，往下走再返回调用sched()的yield()中。在yield()中释放了进程的锁（释放的是在scheduler时获得的锁，目的是保障进程在切入时不会被其他cpu看见），然后返回调用yield的usertrap中
5. 执行usertrap调用yield之后的程序，也就是调用usertrapret()。之后的过程就和用户程序执行系统调用后返回一样。从trapframe中恢复用户线程的的上下文，最后sret回用户空间

在进程切换的过程中，最重要的一点就是围绕swtch函数的调用和返回。因为每次都在线程的context中保存了该线程调用swtch的ra，所以每次调用swtch后都会返回到另一个线程上次调用swtch的地方。

*为什么不需要管pc？*
*因为pc永远都会随着代码执行的每一行而变化。在swtch中保存的pc，也仅仅是swtch指令所在的地址而已，该pc并不能使一个线程切换至另一个线程。只有ra能保证线程的切换*

*为什么只需要保存callee saved寄存器？*
*因为swtch的调用就是一个普通函数的调用。而swtch完成的工作非常简单，并不需要依赖其他的上下文。我们只需要保证swtch的调用者在swtch返回时的上下文一致即可安全完成线程的切换。所以在swtch内部只需要保存和加载callee saved寄存器即可。其他caller saved的寄存器保存在swtch调用者的栈中，在swtch返回时自动恢复。这样就确保了线程调用的swtch返回后上下文一致*

*进程的锁*
*用户进程的锁，无论是切入还是切出过程，都是在两个不同的线程中获得/释放的。切出时，在用户的内核线程执行到yield时获得，在内核调度器线程中释放。切入时在内核调度器线程中获得，在用户内核线程的yield中释放。*
*在代码中（例如yield），直观看到的是获取了锁，调用了swtch，然后释放锁。然而实际上调用swtch之后返回的并不是yield的下一行，所以这把在yield中获得的进程锁并不是直观看到的在yield中释放的*
*这样做的目的都是确保进程切换的过程的串行，进程在此过程中不会被其他cpu看到*

## 用户线程的第一次切换

现在可以回答*启动*一小节时的问题了。当时的问题是：

> 第一个用户进程是怎么进入用户空间的？在刚启动时stvec寄存器写入的是kernelvec的地址，用户trap时运行的uservec函数的地址只用在usertrapret中才写到stvec中。但是整个启动过程并没有看到usertrapret的调用甚至sret的调用。

这是因为当时并不知道线程切换和swtch的神奇作用。

1. 首先在main.c/main()中调用了proc.c/userinit()。userinit中调用的allocproc()函数（包括fork的时候需要获得空闲进程的时候也会调allocproc），从空闲的进程中获取一个进程，对他进行一系列初始化，和线程切换有关的步骤包括

   1. 往p -> context中的ra写入forkret()所在地址
   2. 往p -> context中的sp写入该进程的用户内核栈地址

   随后userinit把该第一个进程状态写为RUNNABLE

2. main()在userinit后调用scheduler。scheduler中自然会把第一个进程找到，因为此时只有它是RUNNABLE。然后调swtch切入第一个进程的内核线程。

3. swtch返回的是forkret所在地址（因为allocproc中把forkret写到了p -> context的ra中。

4. **forkret最终调用usertrapret**，此后uservec地址写入stvec，然后像正常系统调用一样返回用户空间



# 锁

## 自旋锁 spinlock.c

- acquire()：传入自旋锁对象lk，获取自旋锁。其实就是把lk-locked写为1。如果当前已经lk -> locked已经为1，则一直自旋等待。
  - 但是有一种可能：有两个线程同时读到lk -> locked为0，便能同时获得锁。因此使用C提供的从硬件层面串行化的函数__sync_lock_test_and_set()，确保判断locked是否为0并赋值的过程是串行的。
  - 另一个问题是：在一个cpu获取了一把自旋锁到其释放之前，应该**关闭中断**。假设一个线程在已经获取锁的过程中发生了中断，另一个线程也要请求这个锁。如果此时只有一个cpu的话，而cpu又不出让给已经获得了锁的线程，那就是死锁了。
- release()：释放锁的操作。核心就是把lk->locked置为0。同样需要用到C提供的串行化函数。最后打开中断。

## 睡眠锁 sleeplock.c

- 睡眠锁的作用就是：在尝试获得睡眠锁失败后，进程会进入睡眠
- 睡眠锁的实现依赖自旋锁，
  - 从自旋锁的实现中，调用了硬件层面的串行方法，本质上该方法保护的就是sleep-wakeup中的condition，即__sync_lock_test_and_set()和condition lock保护的是同一样东西：就是判断是否睡眠/自旋应当和完成睡眠/自旋的操作原子化。
    自旋锁中的sync_lock_test_and_set()确保了判断locked为0和将locked赋为1是串行的。而condition lock确保判断condition成立和进入睡眠是串行的。
  - 所以一把睡眠锁首先就应该有一把condition lock自旋锁，这个自旋锁的目的就是用来串行地判断我（睡眠锁）是否已经被占用。从sleep-wakeup的角度，这把自旋锁是condition lock，避免lost wakeup；从锁的角度，这把自旋锁的存在相当于人为帮睡眠锁执行了一个类似sync_lock_test_and_set()工作。
- acquiresleep()：
  - 首先获得acquire当前睡眠锁lk的条件锁lk -> lk，这是为了保护之后判断当前睡眠锁是否已经被占用的这个条件。
  - 然后用while判断当前睡眠锁是否已经被占用，即lk -> locked == 1。
  - 如果已经被占用则sleep。首先sleep channel是睡眠锁lk自己（因为之后释放锁的函数也需要传入睡眠锁对象，所以可以通过锁（的地址）本身作为channel完成sleep和wakeup的通信），然后condition lock则是lk -> lk。
  - 所以，condition lock保护的condition就是该睡眠锁自己的locked变量，因此condition lock放在睡眠锁的成员变量中就可以了。
- releasesleep()：获取了条件锁lk->lk后，修改locked变量（这其实就是正式释放睡眠锁了，只不过现在拿着条件锁，别的进程想获取也还得等待，所以是安全的）。然后唤醒在睡眠锁channel睡眠的进程（如果有的话），最后释放条件锁

*思考：sleep和sleeplock的关系：*

## 管道





# 文件系统

## buffer cache

buffer cache层是文件系统中唯一和硬件（驱动层）打交道的。其余关于文件系统的调用都调用cache层的接口

- buf.h：定义了一个buffer cache的内容。
  - 主要是维护了一个data[BSIZE]数组（BSIZE是block size，即块的字节数），所以**一个buf就是一个block的缓存**。
  - 因此还有blockno和dev：本buf缓存内容的设备号和所属blockno。
  - 整个buffer cache是一个双向循环链表，每个buf都是链表中的节点，所以有\*prev和\*next指针用于指向链表中的前、后两个节点。
  - 一把sleeplock：一个buf一次只能被一个进程（线程）访问
- bio.c是整个buffer cache代码：
  - bcache：这个全局静态变量保存了所有的buf对象。
    - buf[NBUF]数组是为了初始化方便，自动有NBUF个buf对象定义在里面了，初始化完成后不会再从该数组中访问buf。
    - head是所有buf组成的双向循环链表的头节点。定义双向循环链表是为了LRU的实现
    - 一把自旋锁，在调整buf链表时使用使用。锁住整个bcache（其实就是为了保护链表）
  - binit()：初始化bcache。主要是初始化了每个buf的锁、bcache锁、以及构建buf链表
  - bget()：传入设备名、blockno，返回对应block的带锁的buf。这是读磁盘中最核心的函数。
    - 首先遍历一次buf链表，如果有对应buf已经符合给定blockno和dev的，修改引用计数后返回即可。
    - 如果没有，说明该块还没有被缓存，则需要驱逐LRU的buf。此时链表从后往前遍历，只要找到第一个遇到的引用计数为0的，则把它驱逐出缓存。具体做法是修改该buf的blockno和dev。然后修改引用计数与buf的valid成员变量为0（bget调用者会处理）。返回此buf
    - 如果两次遍历都没能返回任何一个buf，说明当前所有buf都没有命中且全部为忙（即引用计数都不为0），直接panic掉
  - brelse()：要求buf使用者操作完buf后要调用此函数。主要工作是释放掉buf的睡眠锁（根据睡眠锁的实现，这也会同时唤醒正在等待本锁的进程）。
    并为buf的引用计数-1.若引用计数为0，则把当前buf移到链表头，表明这是刚使用完的。其实这是一个有效的偷懒的做法，逻辑上来说每次被释放都应该把buf放到链表头才对，但引用计数不为0时的buf永远不会被驱逐。所以大可以放心地在引用计数为0时再移当前buf
  - bread()：buffer cache层对外的读接口，传入dev和blockno，获得带锁的buf。外部读文件系统的内容都是通过此接口。
    实现：通过bget获得buf对象，如果当前对象valid == 0，说明是新缓存的对象，所以掉驱动接口virtio_disk_rw往buf里写入对应磁盘block中最新的内容。
  - bwrite()：buffer cache层对外的写接口，传入buf对象，将buf中的内容写入磁盘。调用者必须已经获得了相应buf的锁，否则会panic。然后把通过驱动接口virtio_disk_rw把缓存buf写入对应块。

## inode



