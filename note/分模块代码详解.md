# 启动

1. entry.S：整个内核的入口，通过kernel.ls将其连接到0x80000000的位置，也就是qemu执行首条指令的地址。随后程序为C内核设置一个最开始的栈
2. 跳转到start.c/start()，主要完成从机器模式到监管者模式的切换，初始化时钟中断
3. 跳转到main.c/main()。main()执行几乎所有模块的初始化和启动
4. 各模块初始化完毕后，main()调用userinit()初始化第一个程序。userinit()实际执行了数组initcode中的二进制指令，对应user/initcode.S中的代码，其执行了一个exec系统调用，exec了init用户程序。init通过fork+exec启动shell。
5. shell：父进程一直等待，如果子进程退出，父进程重启shell。

*疑问：在trap初始化时是吧kernelvec写进stvec，作为陷入的入口。而把uservec写入stvec的操作发生在usertrapret中。在内核启动、第一次返回用户空间的时候应该会调用usertrapret才对，不然怎么调用sret返回、以及怎么写好uservec以供后面用户程序系统调用呢？*

*但是没有找到内核第一次返回用户空间时具体发生在哪。在main()执行完userinit()，初始化了第一个进程后，main()最后调用了scheduler，scheduler中调了swtch.S进行任务切换。但是swtch.S中并没有sret*



# 内存

## riscv.h

包含页表操作时用到的几个宏

PGSIZE - 页表字节数：4096

PGSHIFT - PTE偏移量的位数：12。即每个页表的”页内地址“，因为一页表4096字节，所以用12位访问。

PXSHIFT(level)  - 给出多级页表当前需要的层数，返回获得当前级页表的PTE时，当前地址需要右移的位数。

PX(level, va) - 根据虚拟地址和当前层数，获得在PTE在当前页表的地址（偏移量），一共9位（因为一页有512 =  2^9）个PTE

## kernel/vm.c

主要是和页表操作相关的代码。

1. walk()：获取va对应的地址所在的物理页表地址，也就是第三级页表的PTE。

   i. alloc参数：一级页表（根页表）是一定存在的，存在SATP中。而如果alloc == 1，在walk的过程中二、三级页表不存在则创建二、三级页表。如果二三级页表不存在，且alloc == 0或页表创建时内存分配失败，返回0。意味着无法访问va对应pa所在的物理页号。

   最后返回三级页表中的PTE，此PTE保存了va所对应pa所在的物理页。此时的PTE只是“找到对应的”，但是并未检查合法性和其中的值，可能是空的（新分配）。

2. mappages：接收一段不一定对齐的虚拟地址与一个物理地址，及要映射的范围，把范围内所有虚拟页所对应的物理页都映射页表中，返回-1如果创建多级页表时资源分配失败。这个函数只涉及页表映射，不涉及实际资源的分配，即要**先分配了资源，获得了pa，才能调用这个函数将映射写到页表**

3. uvmalloc

   1. 参数：页表、旧的size，新的size
   2. 如果新size大于旧size而且跨页了，那么分配所有包含的新的页。如果某一新页分配失败了，调用uvmdealloc将之前分配的新的页全部回收并返回；如果某一新页分配成功但是也表映射失败了，把那一页回收，同时把之前分配成功的新的页页全部回收并返回。

4. uvmdealloc：传入oldsz和newsz，调用uvmunmap回收页。映射的页表项以及具体分配的页都会被回收。

5. uvmunmap：解除一段连续的虚拟地址范围在页表中的叶子映射并且释放掉相应的物理资源。根据va是可以获得pa的，所以可以在这个函数中完成**删映射+释放物理页**。也可以通过参数指定不释放掉相应的物理页，只删除虚拟地址范围对应的PTE。

6. freewalk：在三级页表的PTE已经全部删除之后才能使用。PTE指向真正物理内存页（而不是下一级页表）的PTE必须已经清除。该函数会将一、二、三级页表的映射以及页表本身全部清除、释放。

7. uvmfree：先调用uvmunmap删除掉一段虚拟地址范围的【叶子PTE】与【对应PTE的物理页】，再通过freewalk删掉页表叶子节点以外的所有PTE。这个函数可以把用户地址空间全部回收。



# 陷入

## 相关寄存器

stvec：内核的中断处理函数的地址。Trap之后把它写入pc
sepc：trap完之后的恢复地址，sret之后sepc写入pc
scause：trap原因描述
sscratch：在中断时可作为缓冲使用
sstatus：SIE位标志设备中断是否启用。如果内核清空SIE，推迟设备中断。SPP位指示中断发生时（前）的特权级，并控制sret返回的模式。

## kernel/trap.c

1. usertrap：
     a. 写kernelvec到stvec，让来自内核的陷入可以跳转到该处

     b. 把sepc寄存器的值存到当前进程的trapframe中。这个值来源于在ecall的时硬件自动保存当时的pc，以让ecall结束后返回用户代码。此处第二次将这值保存到内存是因为usertrap中可能会发生的进程切换，覆盖原有sepc
     c. 根据scause处理陷入。如果scause==8，即系统调用。把trapfrmae中保存的sepc加4,即用户程序ecall后的下条指令。然后调用syscall系统调用分发函数。如果是设备中断，则调devintr()处理。处理完后如果是时钟中断，则让出cpu。

     d. 系统调用返回，则调usertrapret

2. usertrapret：
     a. 把stvec设置回uservec的地址。这里大概可以推断出，来自内核的陷入应该只会发生在usertrapvec到usertrapret之间？或者说一定发生在是在用户陷入的基础之上？
     b. 设置好trapframe中的内核页表、内核栈、usertrap地址、hartid等。这些字段在uservec保存好用户寄存器后，跳转到内核陷入处理函数时需要使用.

     *疑问：trapframe中的这些字段按理来说不会被修改，这样设置是只有第一次返回用户空间的时候有用吗？*
     c. 设置好sepc寄存器为之前保存的（ecall下一行指令的位置）；
     b. 获取（还没设置）satp为用户页表。trapframe中没有保存用户页表的地址，所以需要在这里通过保存在进程结构体中的p->pagetable，作为参数传给userret。
     d. 获取userret地址，传入trapframe与用户页表，调用跳转至userret

## kernel/trampoline.S

此处保存了用户陷入时执行的第一个函数uservec以及内核返回用户空间执行的最后一个函数userret

  1. uservec

  a. 在trap.c中把uservec装进stvec，用户陷入时首先跳转到这里。

  b. 从sscratch获得当前进程的trapframe。sscratch与a0交换使a0可以暂时使用。通过a0地址保存32个当前的寄存器的值（包括存在sscratch中的a0）。然后从trapframe中加载内核栈到sp、加载usertrap地址到t0、加载内核页表到t1并写入satp，然后jr到t0。
  **注意：**uservec的注释中，在切内核页表后写道，“a0此时不再valid”，指a0寄存器的值本来存的是（用户地址空间下的）trapframe，但是内核页表中没有每一个进程的trapframe的映射，所以a0此时的值是没有意义的。

  2. userret
  a. 切用户页表（为了使用trapframe的内容，需要用户页表才有映射）
  b. 根据入参，此时a0是trapframe地址，a1是用户页表（文档说反了）。所以恢复32个通用寄存器的时候需要用到a0的地址，但同时又要恢复a0本身。因此过程是：先把tramframe中保存了的a0值（即ecall前的a0）写入sscratch，然后用当前a0（即作为入参、正指向trapframe的a0寄存器）从trapframe恢复除了a0的寄存器，最后当前a0与sscratch交换。所以sscratch此时同时保存了进程trapframe的地址，下次陷入时可以再使用。
  c. 调用sret返回sepc的地址，恢复陷入前的特权级。



# 系统调用

## user/usys.pl  &  user/usys.S

1. usys.pl是一个生成usys.S的脚本
2. usys.S中定义了用户层面的系统调用接口（函数），所有系统调用都只做两件事
   1. 把当前对应的系统调用号写入a7寄存器中
   2. 调用ecall

## kernel/syscall.h & kernel/syscall.c

1. syscall.h: 定义了所有系统调用的调用号，后续内核处理不同系统调用时根据这个号进行分发
2. syscall.c：ecall之后，根据中断处理函数usertrap，属于系统调用的中断来到syscall.c/syscall()中。syscall()从p->trapframe -> a7获得系统调用号，因为在中断时用户传入a7的系统调用号最终会在中断处理后存到进程的p -> trapframe中。
3. 同理，syscall.c中的获取用户实参的函数argraw()，也是根据p -> trapframe中保存的a0、a1获得用户系统调用的传入参数。

*疑问：在uservec中提到切换内核页表后，由于没有进程trapframe的映射，存放trapframe地址的a0不再有用。那么为什么内核可以通过p -> trapframe访问trapframe呢？*
*因为a0存的是trapframe在进程空间中的虚拟地址。而p -> trapframe存的是trapframe的物理地址。内核使用恒等映射，因此可以直接通过物理地址访问trapframe*

